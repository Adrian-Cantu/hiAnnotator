\name{getFeatureCounts}
\alias{getFeatureCounts}
\title{Get counts of annotation within a defined window around each query range/position.}
\usage{
getFeatureCounts(sites.rd, features.rd, colnam = NULL, chromSizes = NULL,
  widths = c(1000, 10000, 1e+06), weightsColname = NULL,
  doInChunks = FALSE, chunkSize = 10000, parallel = FALSE)
}
\arguments{
  \item{sites.rd}{RangedData/GRanges object to be used as
  the query.}

  \item{features.rd}{RangedData/GRanges object to be used
  as the subject or the annotation table.}

  \item{colnam}{column name to be added to sites.rd for the
  newly calculated annotation...serves as a prefix to
  windows sizes!}

  \item{chromSizes}{named vector of chromosome/space sizes
  to be used for testing if a position is off the mappable
  region. DEPRECATED and will be removed in future
  release.}

  \item{widths}{a named/numeric vector of window sizes to
  be used for casting a net around each position. Default:
  \code{c(1000,10000,1000000)}.}

  \item{weightsColname}{if defined, weigh each row from
  features.rd when tallying up the counts.}

  \item{doInChunks}{break up sites.rd into small pieces of
  chunkSize to perform the calculations. Default is FALSE.
  Useful if you are expecting to find great deal of overlap
  between sites.rd and features.rd.}

  \item{chunkSize}{number of rows to use per chunk of
  sites.rd. Default to 10000. Only used if
  doInChunks=TRUE.}

  \item{parallel}{use parallel backend to perform
  calculation with \code{\link[foreach]{foreach}}. Defaults
  to FALSE. If no parallel backend is registered, then a
  serial version of foreach is ran using
  \code{\link[foreach]{registerDoSEQ}}.}
}
\value{
a RangedData/GRanges object with new annotation columns
appended at the end of sites.rd. There will be a column for
each width defined in widths parameter. If widths was a
named vector i.e. c("100bp"=100,"1K"=1000), then the
colname parameter will be pasted together with width name
else default name will be generated by the function.
}
\description{
Given a query object and window size(s), the function finds
all the rows in subject which are <= window size/2 distance
away. If weights are assigned to each positions in the
subject, then tallied counts are multiplied accordingly.
For large annotations, use
\code{\link{getFeatureCountsBig}}.
}
\note{
\itemize{ \item If the input sites.rd parameter is GRanges
object, then it is converted to RangedData and then
converted back to GRanges at the end since
\code{\link[IRanges]{findOverlaps}} function operates much
faster on RangedData objects.  \item Try not to use this
function for >50 spaces unless you have tons fo memory.
\item If parallel=TRUE, then be sure to have a parallel
backend registered before running the function. One can use
any of the following libraries compatible with
\code{\link[foreach]{foreach}}: doMC, doSMP, doSNOW, doMPI.
For example: library(doMC); registerDoMC(2) }
}
\examples{
# Convert a dataframe to RangedData/GRanges object
data(sites)
head(sites)
alldata.rd <- makeRangedData(sites,soloStart=TRUE)
alldata.rd

data(genes)
head(genes)
genes.rd <- makeRangedData(genes)
genes.rd


geneCounts <- getFeatureCounts(alldata.rd,genes.rd,"NumOfGene")
geneCounts
geneCounts <- getFeatureCounts(alldata.rd,genes.rd,"NumOfGene",doInChunks=TRUE, chunkSize=200)
geneCounts
## Parallel version of getFeatureCounts
# geneCounts <- getFeatureCounts(alldata.rd,genes.rd,"NumOfGene", parallel=TRUE)
# geneCounts
}
\seealso{
\code{\link{makeRangedData}}, \code{\link{makeGRanges}},
\code{\link{getNearestFeature}},
\code{\link{getSitesInFeature}},
\code{\link{getFeatureCountsBig}}.
}

